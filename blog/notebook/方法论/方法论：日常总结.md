
### Domain-Driven Design (DDD/领域驱动设计)

- 聚合：
    - 聚合是用来封装真正的不变性，而不是简单的将对象组合在一起；
    - 聚合应尽量设计的小；
    - 聚合之间的关联通过ID，而不是对象引用；
    - 聚合内强一致性，聚合之间最终一致性；

- 领域模型 - 事务脚本, 面向对象 - 面向过程
    - 事务脚本：围绕功能，以功能为中心。将所有逻辑组织在一个单一过程，进行数据库直接调用，每笔交易（业务请求）都有自己的事务脚本，并且是一个类的公开方法。
    - 领域模型：描述领域类，以类之间的协作完成所需功能。所谓领域模型，是一系列相互关联的对象，每个对象代表一定意义的独立体，既可以一起以一种大规模方式协作；也可以小到以单线方式运行。

- 领域驱动设计的分层
    - Presentation Layer：表现层，负责显示和接受输入；
    - Application Layer(Service)：应用层，很薄的一层，只包含工作流控制逻辑，不包含业务逻辑；
    - Domain Layer(Domain)：领域层，包含整个应用的所有业务逻辑；
    - Infrastructure Layer：基础层，提供整个应用的基础服务；
    
![](http://images.cnitblog.com/i/435188/201406/041031229745840.gif)
    
- 贫血、充血
    - 贫血模型：“行为”（逻辑、过程、Logic/Service/Manager）和“状态”（数据，对象成员变量，VO，DTO）分离不同的对象；（Spring | User+UserService》》userService.save(User user);）
    - 充血模型：面向对象设计的本质，“一个对象是拥有状态和行为的”，（user.save()）
    （绝大多数J2EE开发者都受贫血模型影响非常深）

- 领域驱动设计主张充血模型，也就是富模型的意思，大多业务逻辑都应该被放在Domain Object里面（包括持久化业务逻辑），而Service层应该是很薄的一层，仅仅封装事务和少量逻辑，不和Dao层打交道。）
    - 优点：
        更加符合OO的原则；
        Service层很薄，只充当Facade的角色，不和Dao打交道。
    - 缺点：
        Dao和Domain Object形成了双向依赖，复杂的双向依赖会导致很多潜在的问题。 
        如何划分Service层逻辑和Domain层逻辑是非常含混的
        考虑到Service层的事务封装特性，Service层必须对所有的Domain Object的逻辑提供相应的事务封装方法，其结果就是Service完全重定义一遍所有的Domain Logic，Service层又变成了过程式；

- 小结：
    - 领域模型驱动设计适用于大型复杂的系统，需要很多领域服务协作完成的场景；小型的系统推荐采用传统的mvc即可，将所有的业务逻辑放在service层。
    - 编程分层：业务逻辑层（Controller）、领域服务层（服务方）、数据层；
    - 领域服务层专注于该领域的服务实现，能够灵活应对各种业务变化而不需大幅度主流程代码。
    - 业务逻辑层则关注于主流程，使用并协调各领域开放的服务；
    
---

### 学习方式
- 氛围
- 分享
- 同事
- 知识库
- 中间件
- 开源

### 学习过程
- 修炼内功：找到你的10000小时
- 华山论剑：分享、技术大会
- 行走江湖：仗剑行天下

### 测试驱动开发
- 1、未谋进，先谋退：功能边界、目标；
- 2、保持可运行，可调试的状态；
- 3、可测试性：

### 重构
- 1、两顶帽子：改进代码，新增功能；
- 2、小步前进：改进代码和新增功能的小步骤交替进行，平滑演变；
（在代码写好之后改进它的设计）
- 3、代码的坏味道：重复代码、太长的函数、太长的参数列；
- 4、设计是在整个开发过程中逐渐浮现出来
（随着开发的深入，我们会对很多问题考虑地更加清楚）

### 如何对扩展开放
既然要扩展，势必要兼容各种不同扩展实现，制定一个规范标准，即可对任意扩展开放；
