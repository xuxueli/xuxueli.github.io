
---
### 【JVM工作原理】
介绍一篇[教程](http://blog.csdn.net/cutesource/article/details/5904501) 

#### 一、JVM的生命周期
- 1、JVM实例对应了一个独立运行的java程序，它是进程级别
    - a) 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点
    - b) 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程。
    - c) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出

- 2、JVM执行引擎实例则对应了属于用户运行程序的线程，它是线程级别的


java中线程分为两种类型：**用户线程**和**守护线程**
- 1、 主线程结束后用户线程还会继续运行,JVM存活；主线程结束后守护线程和JVM的状态又下面第2条确定。
- 2、如果没有用户线程，都是守护线程，那么JVM结束（随之而来的是所有的一切烟消云散，包括所有的守护线程）。



补充说明：
- **定义**：守护线程--也称“服务线程”，在没有用户线程可服务时会自动离开。
- **优先级**：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。
- **设置**：通过Thread.setDaemon(false)设置为用户线程；通过Thread.setDaemon(true)设置为守护线程。如果不设置次属性，默认为用户线程。必须在启动前设置；
- example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。
- **生命周期**：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。那Java的守护线程是什么样子的呢。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出。

#### 二、JVM的体系结构
- 1、类装载器（ClassLoader）（用来装载.class文件）
- 2、执行引擎（执行字节码，或者执行本地方法）
- 3、运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈）

#### 三、JVM中类的整个生命周期
加载＝》验证＝》准备＝》解析＝》初始化＝》使用＝》卸载 
- 1、加载
    
    类的加载阶段，主要是获取定义此类的二进制字节流，并将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，最后在Java堆中生成一个代表这个类的java.lang.Class对象作为方法区这些数据的访问入口。相对于类加载过程的其他阶段，加载阶段是开发期可控性最强的阶段。我们可以通过定制不通的类加载器，也就是ClassLoader来控制二进制字节流的获取方式。

- 2、验证

    验证，准备和解析其实都属于连接阶段，而验证就是连接阶段的第一步。这一阶段主要是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全。主要验证过程包括：文件格式验证，元数据验证，字节码验证以及符号引用验证。 

- 3、准备
    
    准备阶段正式为类变量分配内存并设置初始值。这里的初始值并不是初始化的值，而是数据类型的默认零值。这里提到的类变量是被static修饰的变量，而不是实例变量。关于准备阶段为类变量设置零值的唯一例外就是当这个类变量同时也被final修饰，那么在编译时，就会直接为这个常量赋上目标值。

- 4、解析
    
    解析时虚拟机将常量池中的符号引用替换为直接引用的过程。

- 5、初始化
    
    在准备阶段，变量已经赋过一次系统要求的初始值，在初始化阶段，则是根据程序员通过程序的主观计划区初始化类变量和其他资源。
    
    Java虚拟机规范规定了有4种情况必须立即对类进行初始化（加载，验证，准备必须在此之前完成） 
    
    - 1）当使用new关键字实例化对象时，当读取或者设置一个类的静态字段（被final修饰的除外）时，以及当调用一个类的静态方法时，如果类未初始化，则需先初始化。 
    - 2）通过反射机制对类进行调用时，如果类未初始化，则需先初始化。 
    - 3）当初始化一个类时，如果其父类未初始化，先初始化父类。 
    - 4）用户指定的执行主类（含main方法的那个类）在虚拟机启动时会先被初始化。

    除了上面这4种方式，所有引用类的方式都不会触发初始化，称为被动引用。如：通过子类引用父类的静态字段，不会导致子类初始化；通过数组定义来引用类，不会触发此类的初始化；引用类的静态常量不会触发定义常量的类的初始化，因为常量在编译阶段已经被放到常量池中了。
    

- 总结：在上述5个过程当中，验证，准备和解析完全由Java虚拟机主导和控制。只有加载阶段和初始化阶段程序员可以进行控制。在加载阶段可以通过实现自定义的ClassLoader来加载类的二进制流，在初始化阶段程序员则可完全按照需求来为类变量赋值。

**命令行执行java XXX.class的过程 ：**
找到JRE——》找到jvm.dll——》启动JVM并进行初始化——》产生Bootstrap Loader——》载入ExtClassLoader——》载入AppClassLoader——》执行java XXX.class

**JVM两种类装载器包括：**   
- 启动类装载器：是JVM实现的一部分；
- 用户自定义类装载器：则是Java程序的一部分，必须是ClassLoader类的子类。

装载器：    
- Bootstrap ClassLoader
    >这是JVM的根ClassLoader，它是用C++实现的，JVM启动时初始化此ClassLoader，并由此ClassLoader完成$JAVA_HOME中jre/lib/rt.jar（Sun JDK的实现）中所有class文件的加载，这个jar中包含了java规范定义的所有接口以及实现。
- Extension ClassLoader
    >JVM用此classloader来加载扩展功能的一些jar包。
- System ClassLoader
    >JVM用此classloader来加载启动参数中指定的Classpath中的jar包以及目录，在Sun JDK中ClassLoader对应的类名为AppClassLoader。
- User-Defined ClassLoader
    >User-DefinedClassLoader是Java开发人员继承ClassLoader抽象类自行实现的ClassLoader，基于自定义的ClassLoader可用于加载非Classpath中的jar以及目录。

JVM装载顺序： Jvm启动时，由Bootstrap向User-Defined方向加载类；; 应用进行ClassLoader时，由User-Defined向Bootstrap方向查找并加载类；

ClassLoader抽象类的几个关键方法：
- loadClass
>此方法负责加载指定名字的类，ClassLoader的实现方法为先从已经加载的类中寻找，如没有则继续从parent ClassLoader中寻找，如仍然没找到，则从System ClassLoader中寻找，最后再调用findClass方法来寻找，如要改变类的加载顺序，则可覆盖此方法
-findLoadedClass
>此方法负责从当前ClassLoader实例对象的缓存中寻找已加载的类，调用的为native的方法。
- findClass
>此方法直接抛出ClassNotFoundException，因此需要通过覆盖loadClass或此方法来以自定义的方式加载相应的类。
- findSystemClass
>此方法负责从System ClassLoader中寻找类，如未找到，则继续从Bootstrap ClassLoader中寻找，如仍然为找到，则返回null。
- defineClass
>此方法负责将二进制的字节码转换为Class对象
- resolveClass
>此方法负责完成Class对象的链接，如已链接过，则会直接返回。

#### 四、JVM执行引擎
在执行方法时JVM提供了四种指令来执行：
- （1）invokestatic：调用类的static方法
- （2）invokevirtual：调用对象实例的方法
- （3）invokeinterface：将属性定义为接口来进行调用
- （4）invokespecial：JVM对于初始化对象（Java构造器的方法为：<init>）以及调用对象实例中的私有方法时。


#### 五、JVM运行时数据区
- 第一块：PC寄存器
>PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。
- 第二块：JVM栈
>JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址
- 第三块：堆（Heap）

    它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。

    - （1）       堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的
    - （2）       Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配
    - （3）       TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。

- 第四块：方法区域（Method Area）

    - （1）在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。
    - （2）方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class 对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。

- 第五块：运行时常量池（Runtime Constant Pool）
>存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。
- 第六块：本地方法堆栈（Native Method Stacks）
>JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。

#### 六、JVM垃圾回收
**GC的基本原理**：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停

- （1）对新生代的对象的收集称为minor GC；
- （2）对旧生代的对象的收集称为Full GC；
- （3）程序中主动调用System.gc()强制执行的GC为Full GC。

不同的对象引用类型， GC会采用不同的方法进行回收，**JVM对象的引用分为了四种类型**：
- （1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）
- （2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）
- （3）弱引用：在GC时一定会被GC回收
- （4）虚引用：由于虚引用只是用来得知对象是否被GC


---
### 【JVM内存模型以及参数配置】

#### JVM内存模型
- 1、【程序计数器】：
    - 一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器
    - 记录线程正执行的一条字节码指令地址；如果正执行本地方法，那么为空。
    - 线程私有，与线程共存亡，唯一不会OOM的内存区域；
- 2、【java虚拟机栈(JVM Stack)】：
    - 描述Java方法运行过程的内存模型；
    - 栈帧中包含：局部变量表（基本数据类型变量、引用类型的变量、returnAddress类型的变量）、操作数栈、动态链接、方法出口信息等；
    - 一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”；
    - 方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。 
    - 这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。
    - 线程私有，与线程共存亡；
    - 若栈内存大小不允许动态扩展，栈的深度超出最大深度则StackOverFlowError；若内存大小允许动态扩展，线程请求栈时内存用尽无法扩展则OutOfMemoryError；
- 3、【本地方法栈(Local Method Statck)】：
    - 本地方法栈是本地方法(native方法,Java程序同Ｃ程序的接口,比如访问系统硬件)运行的内存模型。
    - 实现和Java虚拟机栈实现的功能类似；参考3；
- 4、【堆(Heap)】：运行时数据区域，所有类实例和数组的内存均从此处分配
    - 存放：对象，几乎所有对象都存储在堆中。
    - 线程共享，虚拟机启动时创建，垃圾回收的主要场所。
    - 堆的划分：不同区域存放不同生命周期的对象，选择不同的垃圾回收算法，更具针对性，更高效。
        - 【新生代(Young Generation)】：
            - Eden Space：用来存放新生的对象，内存最初从这个线程池分配给大部分对象。
            - Survivor Space：分为两个，为From和To，它们的大小总是一样，用于保存在eden space内存池中经过垃圾回收后没有被回收的对象。
        - 【老年代(Old Generation)】：用于保持已经在survivor space内存池中存在了一段时间的对象。
    - 堆的大小既可以固定也可扩展，主流虚拟机堆大小可扩展，线程请求栈时内存用尽无法扩展则OutOfMemoryError；
- 5、方法区：
    - 存放：类信息(已被虚拟机加载)、常量、静态变量、即时编译器编译后的代码等。 
    - Java虚拟机规范中定义方法区，是 "堆" 的一个逻辑部分。 
    - 运行时常量池：存放 常量，
    - 线程共享；
    - 堆的划分：堆的逻辑分区；
        - 【永久代(Perm Gen)】；
    - 内存回收效率低：因为信息一般需要长期存在。仍然回收是为了：对常量池的回收 和 对类型的卸载；
    - Java虚拟机规范对方法区的要求比较宽松，和堆一样允许固定大小也允许可扩展，允许不实现垃圾回收。
    - 常量没被对象引用，也没被变量引用，就需要垃圾收集器回收。 
- 6、直接内存：
    - NIO中引入一种基于通道和缓冲的IO方式。通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的DirectByteBuffer对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。
    - 大小不受Java虚拟机控制，但既然是内存，内存不足时就会抛出OOM异常。 
- 总结：
    - Java虚拟机的内存模型中，两个“栈”，功能类似，方法运行过程的内存模型，内部构造相同，线程私有；
    - Java虚拟机的内存模型中，两个“堆”，方法区本质上是属于堆的一个逻辑部分
    - 堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。
    - 1、2、3 线程私有，4、5 线程共享；
    - Java虚拟机，只有一个堆、一个方法栈。
     
    
- [参考文档](http://blog.csdn.net/u010425776/article/details/51170118)

> 堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。 

#### 常用的几个JVM参数
    -Xms
    JVM初始分配的堆内存大小，默认是物理内存的1/64。
    -Xmx
    JVM最大分配的堆内存大小，默认是物理内存的1/4。
    -XX:PermSize
    JVM初始分配的非堆内存大小，默认是物理内存的1/64。
    -XX:MaxPermSize
    JVM最大分配的非堆内存大小，默认是物理内存的1/4。
    -XX:NewSize
    JVM初始分配的新生代堆区域内存大小。
    -XX:MaxNewSize
    JVM最大分配的新生代堆区域内存大小。
    -XX:ReservedCodeCacheSize
    编译代码时的缓存空间大小。
    
完整的JVM参数，可以参考官方文档： 
- [地址1](http://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html )
- [地址2](http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html) 

```
// 日常开发中，Tomcat内存溢出解决 
-Xms512m 
-Xmx1024m 
-XX:PermSize=512m 
-XX:MaxPermSize=1024m
```

#### JVM内存分配过程
- 1、JVM 会试图为相关Java对象在Eden中初始化一块内存区域。
- 2、当Eden空间足够时，内存申请结束；否则到下一步。
- 3、JVM 试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）。释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区。
- 4、Survivor区被用来作为Eden及Old的中间交换区域，当Old区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区。
- 5、当Old区空间不够时，JVM 会在Old区进行完全的垃圾收集（0级）。
- 6、完全垃圾收集后，若Survivor及Old区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory”错误。

![image](http://image72.360doc.com/DownloadImg/2014/05/0818/41431554_2.png)

#### jvm的内存回收过程，简单过程
对象在Eden Space创建，当Eden Space满了的时候，**GC**就把所有在Eden Space中的对象扫描一次，把所有有效的对象复制到第一个Survivor Space，同时把无效的对象所占用的空间释放。

当Eden Space再次变满了的时候，就启动移动程序把Eden Space中有效的对象复制到第二个Survivor Space，同时，也将第一个Survivor Space中的有效对象复制到第二个Survivor Space。

如果填充到第二个Survivor Space中的有效对象被第一个Survivor Space或Eden Space中的对象引用，那么这些对象就是长期存在的，此时这些对象将被复制到Permanent Generation。

若垃圾收集器依据这种小幅度的调整收集不能腾出足够的空间，就会运行**Full GC**，此时jvm gc停止所有在堆中运行的线程并执行清除动作。

#### 分区的目的
Young Generation由于对象产生的比较多并且大都是朝生夕灭的，所以直接**采用标记-清理算法**。而Old Generation生命力很强，则采用**复制算法**，针对不同情况使用不同算法。

#### 垃圾回收算法

- 复制算法(copying)
> 将内存分成两块，每次只使用其中一块，垃圾回收时，将标记的对象拷贝到另外一块中，然后完全清除原来使用的那块内存。复制后的空间是连续的。**复制算法适用于新生代**，因为垃圾对象多于存活对象，复制算法更高效。在新生代串行垃圾回收算法中，将eden中标记存活的对象拷贝未使用的s1中，s0中的年轻对象也进入s1，如果s1空间已满，则进入老年代；这样交替使用s0和s1。这种改进的复制算法，既保证了空间的连续性，有避免了大量的内存空间浪费。 

![image](http://img.blog.csdn.net/20140101113433906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2luZ29md29ybGQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- 标记-清除算法(Mark-Sweep)
> 适合用于**老年代Full GC**的算法, 从根节点开始标记所有可达对象，其余没标记的即为垃圾对象，执行清除。但回收后的空间是不连续的。

- 标记-压缩算法(Mark-compact)
> 适合用于**老年代**的算法（存活对象多于垃圾对象）。
标记后不复制，而是将存活对象压缩到内存的一端，然后清理边界外的所有对象。

![image](http://img.blog.csdn.net/20140101114509375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2luZ29md29ybGQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 实用命令
```
// 查看线程栈大小
java -XX:+PrintFlagsFinal -version | grep ThreadStackSize

```


---
### 【Java内存模型、内存可见性和指令重排序】

#### JAVA内存模型
目标是定义程序中各个变量的访问规则。(包括实例字段、静态字段和构成数组的元素，不包括局部变量和方法参数)
- 所有的变量都存储在主内存中(虚拟机内存的一部分)。
- 每条线程都由自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。
- 线程之间无法直接访问对方的工作内存中的变量，线程间变量的传递均需要通过主内存来完成。

Java内存模型也规定了工作内存与主内存之间交互的协议，首先定义了8种原子操作：

- Lock(锁定)：作用于主内存中的变量，**把一个变量标识为一条线程独占的状态**。
- Read(读取)：作用于主内存中的变量，把一个变量的值从主内存传输到线程的工作内存中。
- Load(加载)：作用于工作内存中的变量，把read操作从主内存中得到的变量的值放入工作内存的变量副本中。
- Use(使用)：作用于工作内存中的变量，把工作内存中一个变量的值传递给执行引擎。
- Assign(赋值)：作用于工作内存中的变量，把一个从执行引擎接收到的值赋值给工作内存中的变量。
- Store(存储)：作用于工作内存中的变量，把工作内存中的一个变量的值传送到主内存中。
- Write(写入)：作用于主内存中的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。
- Unlock(解锁)：作用于主内存中的变量，把一个处于锁定状态的变量释放出来，之后可被其它线程锁定。

规则：
- 1、不允许read和load、store和write操作之一单独出现。
- 2、不允许一个线程丢弃最近的assign操作，变量在工作内存中改变了之后必须把该变化同步回主内存中。
- 3、不允许一个线程没有发生过任何assign操作把数据从线程的工作内存同步回主内存中。
- 4、一个新的变量只能在主内存中诞生。
- 5、一个变量在同一时刻只允许一条线程对其进行lock操作，但可以被同一条线程重复执行多次。
- 6、如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行read、load操作。
- 7、如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作。
- 8、**对一个变量执行unlock操作前，必须先把该变量同步回主内存中**。

#### volatile型变量

- 1、**保证此变量对所有线程的可见性**。每条线程使用此类型变量前都需要先刷新，执行引擎看不到不一致的情况。**运算结果并不依赖变量的当前值、或者确保只有单一的线程修改变量的值**。变量不需要与其他的状态变量共同参与不变约束。
- 2、**禁止指令重排序优化**。普通的变量仅保证在方法执行过程中**所有依赖赋值结果的地方**都能获取到正确的结果。而不能保证赋值操作的顺序与程序代码中的顺序一致。
- 3、load必须与use同时出现；assign和store必须同时出现。



#### 三个特性：原子性、可见性、有序性
> Java内存模型是围绕着并发过程中如何处理原子性、可见性、有序性这三个特征来建立的，下面是这三个特性的实现原理：

##### 1.原子性(Atomicity)
>基本数据类型的访问读写是具备原子性的，synchronized块之间的操作也具备原子性。

>由Java内存模型来直接保证的原子性变量操作包括read、load、use、assign、store和write六个，大致可以认为基础数据类型的访问和读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock与unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐匿地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块---synchronized关键字，因此在synchronized块之间的操作也具备原子性。

##### 2.可见性(Visibility)
>指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。synchronized(规则8)和final可以保证可见性。Final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把this的引用传递出去，那么在其他线程中就能看见final字段的值。

> 可见性就是指当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的可见性，而普通变量则不能保证这一点。

> 除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store和write操作)”这条规则获得的，而final关键字的可见性是指：被final修饰的字段是构造器一旦初始化完成，并且构造器没有把“this”引用传递出去，那么在其它线程中就能看见final字段的值。

##### 3.有序性(Ordering)
>volatile本身包含了禁止指令重排序的语义，而synchronized则是由规则5获得的，这个规则决定了持有同一个所的两个同步块只能串行地进入。

>  Java内存模型中的程序天然有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。

> Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则来获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。

#### 先行发生原则：
> 如果Java内存模型中所有的有序性都只靠volatile和synchronized来完成，那么有一些操作将会变得很啰嗦，但是我们在编写Java并发代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生”(Happen-Before)的原则。这个原则非常重要，它是判断数据是否存在竞争，线程是否安全的主要依赖。

> 先行发生原则是指Java内存模型中定义的两项操作之间的依序关系，如果说操作A先行发生于操作B，其实就是说发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。它意味着什么呢？如下例：

```
//线程A中执行
i = 1;

//线程B中执行
j = i;

//线程C中执行
i = 2;
```

> 假设线程A中的操作”i=1“先行发生于线程B的操作”j=i“，那么我们就可以确定在线程B的操作执行后，变量j的值一定是等于1，结出这个结论的依据有两个，一是根据先行发生原则，”i=1“的结果可以被观察到；二是线程C登场之前，线程A操作结束之后没有其它线程会修改变量i的值。现在再来考虑线程C，我们依然保持线程A和B之间的先行发生关系，而线程C出现在线程A和B操作之间，但是C与B没有先行发生关系，那么j的值可能是1，也可能是2，因为线程C对应变量i的影响可能会被线程B观察到，也可能观察不到，这时线程B就存在读取到过期数据的风险，不具备多线程的安全性。

> 下面是Java内存模型下一些”天然的“先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。

* a.程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。
* b.管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。
* c.volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。
* d.线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。
* e.线程终于规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。
* f.线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。
* g.对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。
* h.传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

> 一个操作”时间上的先发生“不代表这个操作会是”先行发生“，那如果一个操作”先行发生“是否就能推导出这个操作必定是”时间上的先发生“呢？也是不成立的，一个典型的例子就是指令重排序。所以时间上的先后顺序与先生发生原则之间基本没有什么关系，所以衡量并发安全问题一切必须以先行发生原则为准。

